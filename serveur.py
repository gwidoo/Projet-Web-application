import http.serverimport socketserverfrom urllib.parse import urlparse, parse_qsimport sqlite3import matplotlib.pyplot as pltimport datetime as dtimport matplotlib.dates as pltdfrom urllib.parse import unquoteimport os.pathimport json################################################################################# Classe dérivée pour traiter les requêtes entrantes du serveur#class RequestHandler(http.server.SimpleHTTPRequestHandler):  # nom du serveur  server_version = "serveur.py"  # sous-répertoire racine des documents statiques  static_dir = 'client'  #  # Surcharge du constructeur pour imposer 'client' comme sous-répertoire racine  #  def __init__(self, *args, **kwargs):    super().__init__(*args, directory=self.static_dir, **kwargs)  #  # Traitement des requêtes GET  #  def do_GET(self):    self.init_params()    # on envoie l'heure du serveur    if self.path_info[0] == "regions":      self.send_regions()    # on génère une courbe de ponctualité et on envoie les infos    elif self.path_info[0] == "ponctualite" and len(self.path_info) > 1:      self.send_ponctualite()    # on traite les autres requêtes via la classe parent    else:      super().do_GET()  #  # Traitement de la requête pour une courbe de ponctualité  #  def send_ponctualite(self):    # on récupère le nom de la région    region = unquote(self.path_info[1])    titre = 'Régularité des TER (en %) pour la Région {}'.format(region)    # cache serveur : on génère le fichier uniquement s'il n'existe pas déjà    fichier = 'courbes/ponctualite_{}.png'.format(region)    if not os.path.isfile(fichier):      self.create_figure(region,titre,fichier)     # contenu de la réponse    info = {      "title": titre,      "img" :	'/'+fichier    }    data = json.dumps(info)	    # envoi de la réponse    headers = [('Content-Type','application/json')]    self.send(data,headers)  #  # Génération d'un fichier image pour la ponctualité d'une région donnée  #  def create_figure(self,region,titre,fichier):    # requête SQL    c = conn.cursor()    query = "SELECT * FROM 'regularite-mensuelle-ter' WHERE Région=? ORDER BY Date"    c.execute(query,(region,))    r = c.fetchall()    # erreur sur le nom de la région -> "404 Not Found" via la classe mère    if len(r) == 0:      super().do_GET()      return    # abscisses et ordonnées    x = [pltd.date2num(dt.date(int(a[0][:4]),int(a[0][5:]),1)) for a in r if not a[6] == '']    y = [float(a[6]) for a in r if not a[6] == '']    # décoration des axes    fig1 = plt.figure(figsize=(18,4))    ax = fig1.add_subplot(111)    ax.set_ylim(bottom=80,top=100)    ax.grid(which='major', color='#888888', linestyle='-')    ax.grid(which='minor',axis='x', color='#888888', linestyle=':')    ax.xaxis.set_major_locator(pltd.YearLocator())    ax.xaxis.set_minor_locator(pltd.MonthLocator())    ax.xaxis.set_major_formatter(pltd.DateFormatter('%B %Y'))    ax.xaxis.set_tick_params(labelsize=10)    # génération de la courbe    plt.plot_date(x,y,'bo-',label=region)    # légendes et titre    plt.legend(loc='lower right')    plt.title(titre,fontsize=16)    plt.ylabel('% de régularité')    plt.xlabel('Date')    # enregistrement du fichier image    plt.savefig('client/{}'.format(fichier))  #  # Traitement de la requête pour la liste des régions  #  def send_regions(self):    # requête SQL    c = conn.cursor()    c.execute("SELECT * FROM 'regions'")    r = c.fetchall()        # contenu de la réponse    regions = []    for a in r:      regions.append({        "nom": a[0],        "lat": a[1],        "lon": a[2]      })    body = json.dumps(regions)        # envoi de la réponse    self.send(body,[('Content-Type','application/json')])  #  # Envoi d'une réponse  #  def send(self,body,headers=[]):    self.send_response(200)    # encodage du corps en utf-8    encoded = bytes(body, 'UTF-8')    # envoi des entêtes http    [self.send_header(*t) for t in headers]    self.send_header('Content-Length',int(len(encoded)))    self.end_headers()    # envoi du corps    self.wfile.write(encoded)  #  # Récupération des arguments de la requête  #  def init_params(self):    # décomposition du chemin    info = urlparse(self.path)    self.path_info = info.path.split('/')[1:]    # analyse de la chaîne de requête    self.query_string = info.query    self.params = parse_qs(info.query)################################################################################# Programme principal## ouverture d'une connexion avec la base de donnéesconn = sqlite3.connect('ter.sqlite')# numéro du port TCP utilisé par le serveurserver_port = 8082# instanciation et lancement du serveur webhttpd = socketserver.TCPServer(("", server_port), RequestHandler)httpd.serve_forever()